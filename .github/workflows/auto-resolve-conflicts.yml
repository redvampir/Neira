name: Auto-resolve PR conflicts (prefer PR branch)

# neira:meta
# id: NEI-20250217-github-script-core-fix
# intent: ci
# summary: Убрано повторное объявление core/github и исправлена передача списка PR.
# neira:meta
# id: NEI-20250909-pr-conflict-execsync
# intent: ci
# summary: Заменено использование exec на execSync в github-script во избежание повторного объявления переменной exec.
# neira:meta
# id: NEI-20250906-041548-rerere
# intent: ci
# summary: Включён rerere и добавлен импорт/экспорт кэша конфликтов в auto-resolve.

on:
  # Обновили PR — попробуем починить конфликты
  pull_request:
    types: [opened, reopened, synchronize, edited, labeled]
  # В main что-то влилось — обновим все открытые PR
  push:
    branches:
      - main
      - master
  # Ручной запуск
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  resolve:
    name: Resolve conflicts for PR
    # Запускаем только когда событие связано с PR, либо при пуше в main
    runs-on: ubuntu-latest

    steps:
      - name: Compute context
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            // Когда триггер push, нужно пробежать все открытые PR
            const ev = process.env.GITHUB_EVENT_NAME || '';
            if (ev === 'push') {
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });
              core.setOutput('mode', 'batch');
              core.setOutput('prs', JSON.stringify(prs.map(p => ({
                number: p.number,
                headRef: p.head.ref,
                baseRef: p.base.ref,
                isCrossRepo: p.head.repo.full_name !== (context.repo.owner + '/' + context.repo.repo),
                headRepo: p.head.repo.full_name
              }))));
            } else {
              const p = (context.payload && context.payload.pull_request) ? context.payload.pull_request : null;
              if (!p) { core.setOutput('mode','batch'); core.setOutput('prs','[]'); return; }
              core.setOutput('mode', 'single');
              core.setOutput('prs', JSON.stringify([{
                number: p.number,
                headRef: p.head.ref,
                baseRef: p.base.ref,
                isCrossRepo: p.head.repo.full_name !== (context.repo.owner + '/' + context.repo.repo),
                headRepo: p.head.repo.full_name
              }]));
            }

      - name: Resolve (loop)
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PRS: ${{ steps.ctx.outputs.prs }}
        with:
          script: |
            const { execSync } = require('child_process');

            const prs = JSON.parse(process.env.PRS);
            const isCodex = (ref) => /^codex\//.test(ref) || /codex/i.test(ref);

            for (const pr of prs) {
              core.startGroup(`PR #${pr.number} (${pr.headRef} <- ${pr.baseRef})`);

              if (pr.isCrossRepo) {
                core.info('PR из fork — пропускаем (нет прав пушить в чужой репозиторий).');
                core.endGroup();
                continue;
              }

              try {
                // Чекаут ветки PR из этого же репозитория
                execSync(`git init`, { stdio: 'inherit' });
                execSync(`git config rerere.enabled true`, { stdio: 'inherit' });
                execSync(`git remote add origin https://x-access-token:${process.env.GH_TOKEN}@github.com/${context.repo.owner}/${context.repo.repo}.git`, { stdio: 'inherit' });
                execSync(`git fetch --no-tags origin ${pr.headRef}:${pr.headRef} ${pr.baseRef}:${pr.baseRef}`, { stdio: 'inherit' });
                execSync(`git checkout ${pr.headRef}`, { stdio: 'inherit' });

                // Настраиваем автора коммита
                execSync(`git config user.name "github-actions[bot]"`, { stdio: 'inherit' });
                execSync(`git config user.email "41898282+github-actions[bot]@users.noreply.github.com"`, { stdio: 'inherit' });

                // Импортируем общий rerere-кэш
                try {
                  execSync(`bash -c '
                    set -euo pipefail
                    mkdir -p .git/rr-cache
                    tmpdir=$(mktemp -d)
                    if git ls-remote --exit-code origin refs/heads/rerere-cache >/dev/null 2>&1; then
                      git clone --depth 1 -b rerere-cache https://x-access-token:${process.env.GH_TOKEN}@github.com/${context.repo.owner}/${context.repo.repo}.git "$tmpdir/repo" >/dev/null 2>&1 || true
                      if [ -d "$tmpdir/repo/rr-cache" ]; then
                        cp -R "$tmpdir/repo/rr-cache/." .git/rr-cache/ || true
                      fi
                    fi
                    rm -rf "$tmpdir"
                  '`, { stdio: 'inherit' });
                } catch (e) {
                  core.info('rerere cache import skipped: ' + e.message);
                }

                // ВЛИВАЕМ base В ПОЛЬЗУ НОВОЙ ВЕТКИ:
                // -X ours  => побеждают изменения текущей ветки (PR)
                // Хочешь наоборот — замени на:  -X theirs
                let merged = true;
                try {
                  execSync(`git merge origin/${pr.baseRef} -X ours --no-edit`, { stdio: 'inherit' });
                } catch (e) {
                  merged = false;
                }

                // Если остались незамерженные файлы — отменяем merge
                let unmerged = '';
                try {
                  unmerged = execSync(`git ls-files -u`, { stdio: 'pipe' }).toString().trim();
                } catch (e) {}

                if (!merged || unmerged) {
                  // Не смогли решить конфликты автоматически
                  execSync(`git merge --abort || true`, { stdio: 'inherit' });

                  // Для codex-веток — закрываем PR, чтобы не висел
                  if (isCodex(pr.headRef)) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      body: `🤖 Автослияние не удалось (сложные конфликты). PR закрыт автоматически; создайте новый от свежей базы или вручную решите конфликты.`
                    });
                    await github.rest.pulls.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number,
                      state: 'closed'
                    });
                    core.info('Сложные конфликты: PR закрыт (codex/*).');
                  } else {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      body: `⚠️ Автоматическое разрешение конфликтов не удалось. Проверьте ветку **${pr.headRef}**.`
                    });
                    core.warning('Сложные конфликты: требуется ручное вмешательство.');
                  }

                } else {
                  // Успех — пушим обратно в ветку PR
                  execSync(`git push origin HEAD:${pr.headRef}`, { stdio: 'inherit' });
                  try {
                    execSync(`bash -c '
                      set -euo pipefail
                      [ -d .git/rr-cache ] || exit 0
                      tmpdir=$(mktemp -d)
                      git clone --depth 1 https://x-access-token:${process.env.GH_TOKEN}@github.com/${context.repo.owner}/${context.repo.repo}.git "$tmpdir/repo"
                      cd "$tmpdir/repo"
                      if git ls-remote --exit-code origin refs/heads/rerere-cache >/dev/null 2>&1; then
                        git fetch origin rerere-cache:rerere-cache
                        git switch rerere-cache
                      else
                        git switch --orphan rerere-cache
                        rm -rf ./*
                      fi
                      mkdir -p rr-cache
                      rsync -a --delete "${process.cwd()}/.git/rr-cache/" rr-cache/ || cp -R "${process.cwd()}/.git/rr-cache/." rr-cache/ || true
                      git add rr-cache
                      if git diff --cached --quiet; then
                        echo "No rr-cache changes to commit"
                      else
                        git commit -m "chore(rerere): update cache from auto-resolve"
                        git push origin HEAD:rerere-cache
                      fi
                      rm -rf "$tmpdir"
                    '`, { stdio: 'inherit' });
                  } catch (e) {
                    core.warning('rerere cache export failed: ' + e.message);
                  }
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: `✅ Конфликты автоматически разрешены в пользу ветки PR (strategy: \`-X ours\`).`
                  });
                  core.info('Готово: конфликты решены и изменения запушены.');
                }
              } catch (e) {
                core.warning(`Ошибка при обработке: ${e.message}`);
              }

              core.endGroup();
            }
