# Узлы памяти

## Навигация
- [Обзор Нейры](README.md)
- [Узлы действий](action-nodes.md)
- [Узлы анализа](analysis-nodes.md)
- [Узлы памяти](memory-nodes.md)
- [Архитектура анализа](analysis-architecture.md)
- [Поддерживающие системы](support-systems.md)
- [Личность Нейры](personality.md)
- [Шаблон узла](node-template.md)
- [Политика источников](source-policy.md)

## Оглавление
- [Документ «Узлы памяти»](#документ-узлы-памяти)
  - [1. Назначение и общая концепция](#1-назначение-и-общая-концепция)
  - [2. Стандартная структура узла](#2-стандартная-структура-узла)
  - [Простая реализация (ключ-значение)](#простая-реализация-ключ-значение)
  - [3. Приоритизация источников](#3-приоритизация-источников)
  - [4. Триггерная предварительная загрузка](#4-триггерная-предварительная-загрузка)
  - [5. Оперативная память (кеш) для контекста](#5-оперативная-память-кеш-для-контекста)
  - [6. Автоматическая пересборка черновиков](#6-автоматическая-пересборка-черновиков)
  - [7. Безопасность и контроль доступа](#7-безопасность-и-контроль-доступа)
  - [8. Взаимодействие с узлами анализа](#8-взаимодействие-с-узлами-анализа)
- [Дополнение и развитие концепции узлов памяти](#дополнение-и-развитие-концепции-узлов-памяти)
  - [Типология узлов и связь с контекстом](#типология-узлов-и-связь-с-контекстом)
  - [Инкрементальное обогащение черновика](#инкрементальное-обогащение-черновика)
  - [Система “микрорефлексов”](#система-микрорефлексов)
  - [Комбинация top-down и bottom-up](#комбинация-top-down-и-bottom-up)
  - [Контроль объёма и “теснота”](#контроль-объёма-и-теснота)
  - [Интерактивная адаптация](#интерактивная-адаптация)
  - [Лог виртуальных цитат](#лог-виртуальных-цитат)
- [Жизненный цикл версий узла](../node-lifecycle.md) — состояния и правила переходов между версиями

- [Хранимые данные и методы](#хранимые-данные-и-методы)
- [Проверка валидности узлов](#проверка-валидности-узлов)
- [Игровой опыт и персонализация](#игровой-опыт-и-персонализация)
- [Схемы](#схемы)

Этот документ описывает назначение и устройство узлов памяти, а также принципы работы с ними в системе.

Узлы памяти хранят агрегированные показатели качества (`QualityMetrics`) и статистику использования (`UsageStats`). Они служат прослойкой между узлами анализа и подсистемами ответа, предоставляя базовую выборку знаний.

Каждый узел памяти хранит единицу знания, связанные метрики и журнал ошибок для последующего анализа.

Метрики формируются [узлами анализа](analysis-nodes.md#оценка-качества); узлы памяти не вычисляют их самостоятельно, а только агрегируют поступившие значения.

Перед длительными операциями узлы памяти обязаны проверять `cancel_token` и сохранять текущие данные в чекпоинты. Это позволяет безопасно возобновлять работу после прерывания или переноса задачи.

Полный жизненный цикл версий узла и допустимые переходы между состояниями описаны в [отдельном документе](../node-lifecycle.md).

Схема автоматического пополнения узлов приведена в [отдельном документе](../automatic-population.md).

## Документ «Узлы памяти»

### 1. Назначение и общая концепция
Узлы памяти — это единицы сжатого знания, описывающие понятия, факты, правила и т.д. Они служат точками входа к более подробным данным: внутренним базам (книгам, статьям, дипломным работам, расширенным ответам в чатах), внешним интернет‑ресурсам и другим источникам. Система формирует черновой ответ (или код) на основе ближайших узлов, затем при необходимости дополняет его внутренними и внешними данными.

### 2. Стандартная структура узла
Каждый узел содержит обязательные поля:

- **Идентификатор** — уникальный ID узла. Пример: `node_0001`.
- **Тип** — классификация узла (факт, правило, понятие и т.д.). Пример: `fact`.
- **Краткое описание** — суть узла в одной–двух фразах. Пример: `Закон всемирного тяготения Ньютона`.
- **Метаданные** — ключевые слова, дата обновления, уровень доверия. Пример: `keywords: физика; updated: 2024-02-01; trust: high`.
- **Ссылки** — внутренние или внешние источники. Пример: `[Wikipedia](https://ru.wikipedia.org/wiki/Закон_всемирного_тяготения)`.
- **Приоритет** — числовой показатель важности для выборки. Пример: `0.8`.
- **Версия** — номер редакции узла. Пример: `v1.2`.

### Простая реализация (ключ-значение)
На раннем этапе память можно построить как простое хранилище `ключ → значение`.
Узел содержит минимальный набор полей:

- `id` — уникальный ключ, заполняется вручную;
- `type` и краткое `description` — также вводятся человеком и образуют содержимое записи;
- `metadata` и `links` задаются по необходимости.

Такая реализация не вычисляет приоритеты и метрики, а лишь возвращает сохранённые значения. Позже к ней можно добавить автоматическое обновление `priority`, агрегацию `QualityMetrics` и динамические связи с другими узлами.

### 3. Приоритизация источников

1. **Узлы памяти** — базовая выборка знаний для чернового ответа.
2. **Внутренние базы** — уточнение и расширение при недостатке данных в памяти.
3. **Внешние ресурсы** — привлечение информации из интернета и сторонних источников.

Оценка каждого источника выполняется по трём критериям:

- **Релевантность** — насколько источник соответствует запросу.
- **Доверие** — степень надежности и проверенности данных.
- **Актуальность** — свежесть информации и наличие обновлений.

Итоговый приоритет узла вычисляется из показателей достоверности, актуальности
и востребованности, а также накопленной статистики использования.

```
priority = f(credibility, recency_days, demand)

f(0.9, 2, 50)  -> 0.86
f(0.2, 60, 1)  -> 0.05
```

### 4. Триггерная предварительная загрузка
`AnalysisNode` (или общий оркестратор) анализирует ввод пользователя в реальном времени и при обнаружении слов‑триггеров передаёт команду `ActionNode`. `ActionNode` инициирует предварительную загрузку связанных узлов памяти, экономя время на последующих этапах. Подробнее см. раздел [«Детекция триггеров»](analysis-nodes.md#детекция-триггеров) файла `analysis-nodes.md`.

#### Алгоритм
- **AnalysisNode**
  - отслеживает текстовый поток и выделяет потенциальные темы;
  - при обнаружении триггера формирует команду на предзагрузку.
- **ActionNode**
  - получает команду, запрашивает метаданные и связанные узлы;
  - сохраняет их в оперативный кеш, чтобы последующие обращения проходили без задержки.

#### Примерные слова‑триггеры
- биология
- программирование
- Rust
- математика
- нейросети

#### Предварительно загружаемые данные
- ближайшие узлы памяти: определения, факты и шаблоны;
- индексы связанных документов и ссылок;
- статистику и ранее использованные ответы.

#### Кеширование
Собранные данные помещаются в оперативный кеш с политикой LRU и метками времени. При повторном запросе тех же триггеров система использует уже загруженные сведения, обновляя их при устаревании.

### 5. Оперативная память (кеш) для контекста

Оперативная память выступает временным буфером между запросом пользователя и постоянными узлами. В ней удерживаются:

- актуальный контекст запроса;
- промежуточные расчёты и знания.

Это позволяет быстро обращаться к уже полученной информации без повторного вычисления.

#### Политика сброса и обновления
Хранилище ограничено по размеру и использует политику *Least Recently Used (LRU)*. Когда кеш переполняется, наименее недавно использованные элементы удаляются, освобождая место для новых данных. При смене темы действуют правила сброса или замещения: содержимое кеша может очищаться целиком либо частично, чтобы новая информация не смешивалась с устаревшей.

#### Синхронизация с постоянными узлами
После завершения работы или по таймеру система просматривает содержимое оперативной памяти. Релевантные изменения сериализуются и передаются в постоянные узлы памяти, а временные данные без необходимости сохранения удаляются.

### 6. Автоматическая пересборка черновиков
Система пересчитывает черновой ответ или код при получении новых данных или изменении контекста.

При пересборке система:

- сохраняет промежуточные версии,
- фиксирует триггеры пересборки,
- ведёт лог изменений для контроля качества.

### 7. Безопасность и контроль доступа
- Фильтрация URL.
- Авторизация.
- Разграничение прав доступа.

Доступны списки доверенных доменов и механизм проверки запросов.

### 8. Взаимодействие с узлами анализа
Узлы памяти координируют работу с узлами анализа; подробности см. в документе [«Узлы анализа»](analysis-nodes.md).

#### Обмен метриками
`AnalysisNode` вызывает `push_metrics()` и передает набор параметров: `credibility`, `recency_days`, `demand` и другие. `MemoryNode` использует их для обновления внутреннего рейтинга и оценки актуальности записей.

#### Передача ссылок
После выполнения запроса `AnalysisNode` возвращает ссылки на использованные источники. `MemoryNode` добавляет их в поле `links`, фиксируя происхождение сведений.

#### Обработка длинных запросов
При длительных вычислениях взаимодействие продолжается асинхронно с помощью планировщика задач; подробности в разделе [TaskScheduler](support-systems.md#taskscheduler) файла `support-systems.md`. Планировщик распределяет задачи, а `MemoryNode` по мере готовности результатов обновляет контекст и метаданные.

## Дополнение и развитие концепции узлов памяти

### Типология узлов и связь с контекстом
Выделите разные типы узлов памяти — факты, правила, понятия, ссылки и т.п. — чтобы при выборке данных учитывать семантику запроса. Это позволит быстрее находить нужную «гранулу знания» и сокращать объём лишнего контента в ответе.
Например, узлы типа «краткий факт» могут иметь более высокий приоритет для предварительной загрузки, а «подробное описание» — для уточнения ответа.

### Инкрементальное обогащение черновика
Рассмотрите процесс пошагового обогащения чернового ответа:

1. Сначала система генерирует короткий набросок, используя ближайшие узлы памяти.
2. Затем добавляет детализацию, подключаясь к внутренним базам знаний.
3. И только в конце, при необходимости, обращается к внешним ресурсам.
Так можно избежать «перебора» данных и оптимизировать время отклика.

### Система “микрорефлексов”
Помимо ключевых слов триггеров (биология, Rust и т.д.), можно добавить «микрорефлексы» — микро-правила, реагирующие на более узкие паттерны (например, «генетические алгоритмы» или «async/await»). Они запускали бы дополнительные модули поиска, если детектируется субтема.

### Комбинация топ-Down и bottom-Up
В дополнение к централизованному алгоритму поиска полезно внедрить bottom-up подход: узлы, связанные с уже найденными, могут «выступать с инициативой» и предлагать себя для дальнейшей выборки. Это позволяет системе выходить на неожиданные, но релевантные детали.

### Контроль объёма и “теснота”
Важно контролировать, сколько узлов одновременно загружаются в оперативную память. Использование «тесноты» или «охвата» — показатели, сколько узлов относят себя к одной теме и насколько они взаимосвязаны. Если система видит, что охват стал слишком широким, можно автоматически ограничить количество узлов, чтобы не потерять фокус.

### Интерактивная адаптация
Во время обсуждения с пользователем система может отслеживать, какие детали вызывают уточнения или дополнительные вопросы. Эти сигналы могут менять приоритеты: например, если пользователь не удовлетворён поверхностным ответом, система усиливает запрос более подробных и авторитетных источников.

### Лог виртуальных цитат
Чтобы пользователю было понятно, откуда берётся информация, полезно вести лог «виртуальных цитат» — меток, указующих, какие узлы памяти или базы были задействованы. Это повышает прозрачность и помогает выбирать, какие части информации сохранять, обновлять или удалять.

Такой подход позволяет гибко управлять информацией, подгружать лишь необходимое и поддерживать баланс между скоростью, точностью и масштабируемостью.

### Связанные базы знаний
Узлы памяти могут ссылаться на внешние и внутренние хранилища данных. Для интеграции рекомендуется использовать свободно распространяемые решения:

- SQL (PostgreSQL, MySQL/MariaDB, SQLite)
  Доступ: SQL-запросы через драйверы или ORM (psycopg2, SQLAlchemy, Sequelize и т.п.)
- NoSQL (MongoDB, CouchDB)
  Доступ: HTTP/REST или клиентские библиотеки, работающие с документами
- Графовые (Neo4j Community Edition, JanusGraph)
  Доступ: запросы Cypher или Gremlin по Bolt/HTTP
- Векторные (FAISS, Milvus Community)
  Доступ: API поиска по эмбеддингам (Python/REST/gRPC клиенты)

#### Формат ссылок/идентификаторов
Поле ссылок в узле памяти хранит унифицированные URI, указывающие на конкретный объект в базе знаний:

- `sql://{db}/{table}/{primary_key}`
- `nosql://{db}/{collection}/{document_id}`
- `graph://{db}/{label}/{node_id}`
- `vector://{index}/{vector_id}`

Дополнительно допускаются параметры `?version=...&meta=...` для версии и сопутствующих метаданных.

## Хранимые данные и методы

### Структуры

```rust
struct QualityMetrics {
    credibility: f32,    // 0..1
    recency_days: u32,   // возраст данных
    demand: u32,         // число запросов
}

struct UsageStats {
    calls: u64,          // количество обращений
    last_access: u64,    // timestamp последнего обращения
}
```

### Методы

- `update_from_analysis(node_id, QualityMetrics)` — приём метрик от Analysis‑узла;
- `get_priority()` — получение текущего приоритета;
- `update_priority()` — пересчёт приоритета с учётом накопленных данных.

## Проверка валидности узлов

Для сохранения качества ответы опираются только на проверенные узлы памяти. Валидность оценивается в несколько этапов:

### Метрики

- `credibility` и связанные показатели должны превышать минимальные пороги; значения ниже 0.3 приводят к отбраковке узла.
- `recency_days` ограничивается верхней границей, что предотвращает использование устаревших данных.
- показатели популярности (`demand`, `calls`) помогают выявлять редко используемые и, возможно, лишние записи.

### Автоматические тесты

- линтеры и unit‑тесты проверяют целостность структуры узла;
- property‑тесты моделируют типичные сценарии использования и фиксируют ошибки в журнале узла.

### Ручная проверка

- модератор просматривает журнал ошибок, подтверждает источник данных и при необходимости корректирует объяснение узла;
- спорные записи отправляются на повторный анализ или полностью исключаются из базы.

### Примеры обработки некорректных узлов

- **Отбраковка**: `credibility < 0.3` или множество ошибок в журнале — узел удаляется вызовом `reject(node_id)` и помечается для повторного сбора данных.
- **Корректировка**: если `recency_days` превышает порог, запрашивается актуализация сведений и выполняется `update_from_analysis` с новой метрикой; после успешного прогона тестов узел вновь становится активным.

## Игровой опыт и персонализация
Узлы памяти сохраняют опыт общения с пользователем и данные игровых сессий. Игровые взаимодействия используются как дополнительный источник обучения: из них выделяются новые факты и создаются вспомогательные узлы. Система адаптирует стиль общения под пользователя, но базовое ядро личности остаётся неизменным.

## Схемы

JSON‑схемы расположены в каталоге [../../schemas](../../schemas). При несовместимых изменениях повышайте версию: `1.0.0` → `1.1.0`.
