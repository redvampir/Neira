# Нейра — саморазвивающийся ИИ‑модуль

## Навигация
- [Узлы действий](action-nodes.md)
- [Узлы анализа](analysis-nodes.md)
- [Узлы памяти](memory-nodes.md)
- [Архитектура анализа](analysis-architecture.md)
- [Поддерживающие системы](support-systems.md)
- [Личность Нейры](personality.md)
- [Шаблон узла](node-template.md)
- [Политика источников](source-policy.md)
- [Пример использования](usage-example.md)
- [Практическое руководство](practical-guide.md)
- [Глоссарий](glossary.md)
- [FAQ](faq.md)
- [Загрузка обучающих данных](training.md)
- [Развертывание Neira](deployment.md)
- [Тестирование Neira](testing.md)
- [Дорожная карта Neira](roadmap.md)
- [Структура управления Нейры](governance-structure.md)
- [Мотивация и прогресс Нейры](motivation.md)

## Оглавление
- [Назначение](#назначение)
- [Технические требования](#технические-требования)
  - [Минимальное окружение](#минимальное-окружение)
  - [Распределение вычислений](#распределение-вычислений)
  - [Доступ к аппаратным ускорителям](#доступ-к-аппаратным-ускорителям)
  - [Архитектура памяти](#архитектура-памяти)
  - [Резервирование](#резервирование)
- [Минимальная конфигурация (MVP)](#минимальная-конфигурация-mvp)
- [Ключевые компоненты](#ключевые-компоненты)
- [Поддерживающие системы](#поддерживающие-системы)
- [Планировщик и лимиты итераций](#планировщик-и-лимиты-итераций)
- [Эволюция и оптимизация](#эволюция-и-оптимизация)
- [Автономное создание подтипов и метаданные](#автономное-создание-подтипов-и-метаданные)
- [Эмоции, желания и этика](#эмоции-желания-и-этика)
- [Интеграция с редакторами/IDE](#интеграция-с-редакторамиide)
- [План разработки](#план-разработки)
- [Использование](#использование)
- [Дополнительная документация](#дополнительная-документация)

## Назначение

**Нейра** — экспериментальный модуль искусственного интеллекта,
который расширяет возможности редакторов и IDE за счёт самообучения,
планирования и интерактивного взаимодействия с пользователем.
Модуль строится как набор узлов (nodes), которые можно объединять,
оптимизировать и визуализировать в совместимых интерфейсах.

## Технические требования

Эти требования описывают минимальные системные ресурсы, необходимые для запуска Нейры.

### Минимальное окружение

Ниже приведён минимальный набор системных ресурсов и зависимостей, достаточный для запуска Нейры:

- **ОС**: Linux x86_64 (проверено на Ubuntu 22.04 LTS).
- **CPU**: 4 ядра x86_64 или ARM, 2 ГГц+.
- **RAM**: минимум 8 ГБ (рекомендуется 16 ГБ).
- **Диск**: 10 ГБ свободного пространства.
- **Сеть**: гигабитная LAN или выше, RTT <1 мс.
- **Node.js**: версия 20 LTS или выше.
- **Rust**: версия 1.75 или выше.

GPU необязательна; для обучения и больших моделей желателен CUDA‑совместимый ускоритель с 6 ГБ VRAM.

Для расширения и ускорения вычислений можно использовать оборудование уровня [NVIDIA Data Center GPU](https://www.nvidia.com/en-us/data-center/).

#### Стандартная конфигурация

Для комфортной разработки рекомендуется использовать стандартную конфигурацию:

- 8-ядерный CPU ≥2.5 ГГц
- 32 ГБ RAM
- SSD 512 ГБ
- Опциональная CUDA-совместимая GPU ≥8 ГБ VRAM

Эта конфигурация обеспечивает баланс удобства разработки и стоимости и применяется по умолчанию, если проект не предъявляет особых требований.

Примечание: операционные лимиты планировщика устанавливаются отдельно и поддерживаются ниже указанных значений, чтобы оставлять резерв для хоста и других процессов.

Бюджет `TaskScheduler` всегда задаётся меньше физических ресурсов и служит внутренним ограничением для распределения задач. Например, на машине с 4 CPU и 8 ГБ RAM планировщик по умолчанию резервирует 2 CPU и 4 ГБ, оставляя остальное хосту.

### Распределение вычислений

- **CPU**: планировщик, InteractionHub, обработка памяти.
- **GPU**: обучение, тяжёлые матричные операции.

### Доступ к аппаратным ускорителям

Neira может использовать дополнительные ускорители (GPU, TPU, FPGA) для выполнения ресурсоёмких задач. Общая схема подключения:

1. Узел указывает требуемый тип ускорителя в поле `required_accelerator` метаданных.
2. `TaskScheduler` распределяет задачи по доступным устройствам, учитывая это поле.
3. При запуске узел проверяет наличие нужного ускорителя и завершает работу с ошибкой, если устройство недоступно.

Для взаимодействия с различными устройствами применяются специализированные crates:

- [`wgpu`](https://crates.io/crates/wgpu) — универсальный доступ к GPU на разных платформах;
- [`cuda`](https://crates.io/crates/cuda) — API для NVIDIA GPU;
- [`opencl`](https://crates.io/crates/opencl3) — интерфейс для OpenCL‑совместимых GPU/FPGA.

Пример узла, который требует GPU и проверяет его наличие:

```rust
use anyhow::{Result, bail};
use wgpu::Instance;

enum Accelerator {
    Gpu,
    // другие варианты: Tpu, Fpga
}

struct Node {
    required_accelerator: Accelerator,
}

impl Node {
    fn start(&self) -> Result<()> {
        match self.required_accelerator {
            Accelerator::Gpu => {
                let instance = Instance::default();
                if instance.enumerate_adapters(wgpu::Backends::all()).next().is_none() {
                    bail!("GPU accelerator not available");
                }
            }
        }
        Ok(())
    }
}
```

### Архитектура памяти

Память Нейры организована по уровням — от самых быстрых к более ёмким и медленным хранилищам:

1. **CPU‑кэш** — микросекундный доступ к данным, задействованным в текущих вычислениях.
2. **ОЗУ** — основная рабочая область, где хранится оперативный контекст и структуры данных узлов.
3. **VRAM GPU** — тензоры и модели, используемые для ускоренных операций на графических процессорах.
4. **NVRAM/PMEM** — энергонезависимая память с задержкой порядка сотен наносекунд и объёмами десятки–сотни гигабайт.
5. **SSD** — постоянные узлы памяти и индексы, требующие быстрого чтения и записи.
6. **HDD** — архивы и редко запрашиваемые данные, переносимые в медленное хранилище.
7. **Базы данных** — активные располагаются на SSD, архивные — на HDD.

Последние уровни задействуются по мере роста объёма знаний и потребности в долговременном хранении.

### Резервирование

Для предотвращения потери данных используется зеркалирование SSD и активных баз данных (RAID 1/5). Критичные узлы памяти дублируются на резервных машинах, что позволяет быстро восстановить работу при отказе оборудования.

**Критерии выбора стратегии:**
- критичность узла;
- стоимость простоя;
- объём данных.

## Личность Нейры

Стартовый образ и правила развития описаны в [отдельном документе](personality.md).
Кратко: на старте система проецирует образ 14‑летней девочки, увлекающейся анализом и играми.
По мере роста функциональности персонаж взрослеет до примерно 30 лет, но базовые черты сохраняются.
При необходимости доступен режим без личности для сухих академических ответов.

## Минимальная конфигурация (MVP)

Базовая версия Neira реализуется на Rust и включает:

1. **Коммуникационный узел (Chat Node)** – Telegram или Discord‑бот для диалога с разработчиком.
2. **Узел генерации кода (Code Node)** – создаёт и модифицирует исходный код.
3. **Узел саморазвития (Self-Improve Node)** – анализирует систему и предлагает патчи.
4. **Узлы действий, анализа и памяти** – определяют и выполняют операции, хранят знания.
5. **Рабочая память** – удерживает текущий контекст и промежуточные результаты.
6. **Базовый планировщик** – распределяет задачи и ограничивает итерации.
7. **Интерфейс разработчика** – просмотр логов, подтверждение изменений, запуск обучения.
8. **Контролируемая среда обучения** – загрузка книг и локальных источников.
9. **Ядро личности** – правила и ценности, влияющие на ответы.

Этот минимальный набор служит отправной точкой и будет расширяться по мере развития Нейры.

На ранних этапах при необходимости подключается внешний тьютор (например, LLM‑сервис),
помогающий с подсказками и обучением. Архитектура рассчитана на постепенное
саморазвитие, поэтому зависимость от тьютора со временем исчезает.

## Ключевые компоненты

![Диаграмма систем Neira](architecture.svg)

### 1. Узлы действий (Action Nodes)
Отвечают за конкретные операции: вывод текста,
запросы к API, генерацию кода, мониторинг состояния и т.д.

```rust
struct ActionNode {
    id: String,
    action_type: ActionType,
    connections: HashMap<String, f32>,
    execution_cache: LruCache<String, ExecutionResult>,
    metrics: ActionMetrics,
}
```

### 2. Узлы анализа (Analysis Nodes)
Обрабатывают запросы, строят логические цепочки,
оценивают достоверность данных и выбирают нужные действия. В базовом интерфейсе обязательны
поля `id`, `analysis_type`, `status`, `links`, `confidence_threshold` и `metadata.schema`. Цепочка рассуждений (`reasoning_chain`) формируется во время анализа и хранится в `AnalysisResult`.

```rust
struct AnalysisNode {
    id: String,
    analysis_type: AnalysisType,
    status: NodeStatus,
    links: Vec<String>,
    confidence_threshold: f32,
    metadata: AnalysisMetadata,
}

struct AnalysisMetadata {
    schema: String,
    // дополнительные метаданные
}
```

`status` фиксирует состояние узла (`draft`, `active`, `deprecated`, `error`) и
используется планировщиком и системами ревизий. Обязательное поле `links`
перечисляет связанные узлы и помогает планировщику ориентироваться в графе.
`confidence_threshold` задаёт минимальную допустимую `credibility` для принятия результата,
а `metadata.schema` содержит версию схемы описания узла. Последовательность рассуждений возвращается отдельно в `AnalysisResult`, что упрощает аудит и отладку.

При выполнении `analyze()` узел формирует `AnalysisResult` с метриками `quality_metrics`,
цепочкой `reasoning_chain`, вычисленным `uncertainty_score` и ссылками на использованные источники.

### 3. Узлы памяти (Memory Nodes)
Хранят знания и опыт, поддерживают приоритизацию источников
и ведут журнал ошибок.

```rust
struct MemoryNode {
    id: String,
    data_type: MemoryType,
    priority_level: Priority,
    source_reliability: SourceReliability,
    access_frequency: u32,
    last_accessed: DateTime<Utc>,
}
```

### 4. Личностные модули
Включают элементы, отвечающие за образ персонажа и игровые сценарии:
- **Диалоговая логика** — определяет намерение пользователя и выбирает стиль ответа.
- **Модуль личности** — хранит устойчивый образ Нейры и позволяет отключать его при необходимости.
- **Модуль интересов и игр** — обеспечивает обучение через участие в играх и формирование новых аналитических узлов.
- **Модуль скепсиса и проверки** — добавляет уточнения и проверку фактов.

### Взаимодействие с другими узлами

Узлы связываются через направленные рёбра данных и событий, формируя граф выполнения.

```mermaid
flowchart LR
    Action[Узел действия] -->|событие| Analysis[Узел анализа]
    Analysis -->|контекст| Memory[Узел памяти]
    Memory -->|обновление| Analysis
    Analysis -->|команда| Action
```

## Поддерживающие системы
- **Рабочая память и внимание** — отслеживает текущий контекст диалога,
  фокусируется на релевантных данных, очищает устаревшие записи.
- **Планирование и цели** — разбивает задачи на подцели,
  оценивает ресурсы и отслеживает прогресс.
- **Учёт неопределённости** — для каждого вывода вычисляется вероятность
  и объясняется источник сомнений.
- **Метапознание** — модуль самооценки анализирует собственные рассуждения
  и выбирает альтернативные стратегии.

Подробнее см. [поддерживающие системы](support-systems.md).

## Планировщик и лимиты итераций

Этот раздел описывает операционные лимиты планировщика. Они определяют, сколько времени и итераций выделяется узлам и не являются пределами физических ресурсов системы.

`TaskScheduler` распределяет задачи по очередям `fast`, `standard` и `long`, учитывая параметры `priority`, `max_iterations` и `time_slice_ms`. Подробности см. в разделе [TaskScheduler](support-systems.md#taskscheduler).

Планировщик может учитывать отдельный бюджет `pmem_limit_mb` для энергонезависимой памяти, чтобы узлы не превышали доступный объём NVRAM.

Планировщик определяет порядок активации узлов и контролирует количество циклов обработки. Он поддерживает приоритеты, задержки и политики останова.

### Базовые параметры

Каждый узел может задавать:

- **priority** — значение от 0 до 10, чем выше, тем раньше выполняется узел;
- **max_iterations** — предел повторов, предотвращает бесконечные циклы;
- **time_slice_ms** — квант времени, после которого управление передаётся другому узлу.

```toml
[scheduler]
default_priority = 1
max_iterations = 32
time_slice_ms = 10
```

Параметры можно переопределять в пользовательском профиле или через UI.

Операционные лимиты планировщика обычно ниже доступных аппаратных ресурсов, чтобы оставлять резерв для системы и параллельных процессов.

### Тонкая настройка

Планировщик отслеживает фактическое время выполнения узлов и автоматически корректирует лимиты. Для долгих задач лимиты могут увеличиваться, для фоновых — снижаться. Пользователь может задать глобальный предел по времени или количеству итераций, после которого выполнение приостанавливается с уведомлением.

## Эволюция и оптимизация
Нейра отслеживает часто используемые цепочки узлов и создаёт «мосты» (BridgeNode)
для ускорения повторяющихся операций. Метрики успеха, производительности
и частоты использования формируют вес оптимизации. Возможна кодогенерация
новых узлов с последующим ручным подтверждением разработчика.

- Новые узлы запускаются параллельно со старыми.
- Пользователь тестирует устойчивость и функциональность.
- После одобрения новая версия становится основной, а прежняя архивируется или удаляется.

Связанные этапы описаны в [жизненном цикле узлов](../node-lifecycle.md).

## Автономное создание подтипов и метаданные

При обнаружении повторяющихся шаблонов взаимодействий система создаёт новые специализированные подтипы узлов. Процесс включает анализ метрик, генерацию исходного кода и описание метаданных.

```json
{
  "subtype": "analysis/semantic-filter",
  "version": 1,
  "author": "neira",
  "parameters": { "threshold": 0.7 },
  "connections": ["memory/long-term", "action/report"]
}
```

Метаданные хранятся в формате JSON и используются редактором для визуализации и проверки совместимости. Пользователь может разрешить автоматическое добавление подтипов или требовать ручного подтверждения.

## Эмоции, желания и этика
Имитация эмоций упрощает общение с пользователем. Настоящие эмоции
служат механизмами саморегуляции (лень, любопытство и т.д.). Система
гипер‑желаний позволяет задавать стратегические цели, на основе которых
формируются более конкретные задачи.

## Интеграция с редакторами/IDE
- Написан на Rust и может запускаться как отдельный сервис или библиотека.
- Визуализация узлов и их связей возможна в редакторах, поддерживающих
  @VISUAL_META‑метаданные.
- Обмен данными осуществляется через WebSocket или другие API,
  что позволяет подключать различные фронтенд‑платформы.

## План разработки
1. **Базовые узлы и рабочая память** — создание Action/Analysis/Memory узлов
   и механизма контекста.
2. **Планирование и неопределённость** — внедрение PlanningSystem
   и UncertaintyQuantification.
3. **Метапознание и оптимизация** — запуск систем самооценки и мостов.
4. **Эмоции и желания** — добавление имитации эмоций, саморегуляции
   и гипер‑желаний.
5. **Визуализация и интеграция** — полноценное отображение узлов,
   трассировка и отладка внутри выбранного редактора или IDE.

## Использование
Модуль может запускаться как часть backend приложения или как отдельный процесс.
Функциональность можно подключать поэтапно, позволяя разработчикам
добавлять узлы и адаптировать поведение системы под потребности
конкретного проекта.

Подробные инструкции по установке зависимостей,
запуску демонстрационной конфигурации и настройке
переменных окружения приведены в [deployment.md](deployment.md).

## Дополнительная документация
- [Узлы действий](action-nodes.md)
- [Узлы памяти](memory-nodes.md)
- [Узлы анализа](analysis-nodes.md)

## Схемы

JSON‑схемы расположены в каталоге [../schemas](../schemas). При несовместимых изменениях повышайте версию: `1.0.0` → `1.1.0`.
