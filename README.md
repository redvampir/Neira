<!-- neira:meta
id: NEI-20250305-readme-cell-examples
intent: docs
summary: Обновлены требования к runtime и пример с CellRegistry.
-->
<!-- neira:meta
id: NEI-20260413-readme-rename
intent: docs
summary: Обновлены ссылки на каталог spinal_cord и API.
-->
<!-- neira:meta
id: NEI-20240918-readme-brain
intent: docs
summary: Добавлен раздел о модуле brain и ссылка в навигации.
-->
# Нейра — саморазвивающийся ИИ‑модуль



Assistant Quick Links
- Start Here: AGENTS.md
- Teamwork: TEAMWORK.md
- Workflow: WORKFLOW.md
- Coding Guidelines: CODING_GUIDELINES.md
- Spinal cord API: docs/api/spinal_cord.md

Documentation Index
- docs/index.md — карта документации (DocMap) для GitHub/IDE
- docs/README.md — вход в документацию
<!-- neira:meta
id: NEI-20250325-factory-nav-link
intent: docs
summary: Добавлена ссылка на систему фабрикаторов в навигации.
-->
## Навигация

- [Клетки действий](docs/cells/action-cells.md)
- [Клетки анализа](docs/cells/analysis-cells.md)
- [Клетки памяти](docs/cells/memory-cells.md)
- [Архитектура анализа](docs/system/analysis-architecture.md)
- [Мозг](docs/system/brain.md)
- [Поддерживающие системы](docs/system/support-systems.md)
- [Личность Нейры](docs/meta/personality.md)
- [Шаблон клетки](docs/cells/cell-template.md)
- [Генератор шаблонов клеток](docs/cells/cell-template.md#генератор-шаблонов)
- [Политика источников](docs/system/source-policy.md)
- [Низкоуровневая цепочка инструментов](docs/system/low-level-toolchain.md)
- [Система самообновления](docs/system/self-updating-system.md)
- [Система фабрикаторов (Stem Cell Factory System)](docs/design/factory-system.md)
- [Нервная система](docs/design/nervous_system.md)
- [Пример использования](docs/guides/usage-example.md)
- [Орган билдер CLI](docs/guides/usage-example.md#organ-builder-cli)
- [CLI‑утилита валидации шаблонов](docs/legacy/usage-example.md)
- [Практическое руководство](docs/guides/practical-guide.md)
- [Глоссарий](docs/meta/glossary.md)
- [FAQ](docs/meta/faq.md)
- [Документация по обучению (сценарный клетка)](spinal_cord/TRAINING.md)
- [Загрузка обучающих данных](docs/guides/training.md)
- [CI/CD и деплой](docs/legacy/deployment.md)
- [Веб-интерфейс обучения](docs/guides/web-interface.md)
- [Тестирование Neira](docs/guides/testing.md)
- [Дорожная карта Neira](docs/roadmap.md)
- [Структура управления Нейры](docs/system/governance-structure.md)
- [Мотивация и прогресс Нейры](docs/meta/motivation.md)
- [Сбор и диагностика метрик](docs/metrics_cells.md)
- [Как отключить или ограничить мониторинг](docs/metrics_cells.md#как-отключить-или-ограничить-мониторинг)
- [Иммунная система](docs/immune_system.md)

## Модуль brain

Мозг (`brain`) — центральный орган управления Нейры. Он получает сообщения из
`DataFlow`, публикует события через `EventBus` и распределяет задачи через
`TaskScheduler`. Подробнее см. [описание мозга](docs/system/brain.md).

<!-- neira:meta
id: NEI-20260519-dataflow-controller
intent: docs
summary: Добавлен раздел о DataFlowController и связи органов с мозгом.
-->

### DataFlowController и циркуляция данных

`DataFlowController` — «кровоток» Нейры. Каждый орган при инициализации
получает ссылку (`attach_flow_controller`, `set_flow_controller` и т.п.) и
отправляет свои сообщения (`FlowMessage`) в общий поток. Мозг читает их из
приёмника контроллера, публикуя `FlowEvent` в `EventBus` и задачи
(`TaskPayload`) в `TaskScheduler`.

```
[Органы] → [DataFlowController] → [Brain] → [EventBus] → [Органы]
                    ↘
                     → [TaskScheduler] → [Органы]
```

Так обеспечивается единая циркуляция данных: органы сообщают о событиях,
мозг принимает решения и возвращает команды обратно в систему.

<!-- neira:meta
id: NEI-20270223-readme-digestive-overview
intent: docs
summary: Кратко описан DigestivePipeline и пример использования.
-->

### DigestivePipeline — нормализация входа

`DigestivePipeline` принимает сырой текст в форматах JSON, YAML или XML,
проверяет его по JSON Schema из `spinal_cord/config/digestive.toml`
(переопределяется переменной `DIGESTIVE_CONFIG`) и сохраняет результат в
`MemoryCell`. Использование:

```rust
use backend::digestive_pipeline::DigestivePipeline;

DigestivePipeline::init().expect("digestive config");
let parsed = DigestivePipeline::ingest(raw)?; // ParsedInput
```

Пример отключения мониторинга в `.env`:

```
NERVOUS_SYSTEM_ENABLED=false
PROBES_HOST_METRICS_ENABLED=false
PROBES_IO_WATCHER_ENABLED=false
```

Подробнее см. [Как отключить или ограничить мониторинг](docs/metrics_cells.md#как-отключить-или-ограничить-мониторинг).

Для проверки целостности файлов используется переменная окружения `INTEGRITY_ROOT`,
но в большинстве случаев её не нужно задавать вручную. При старте клетка
[BasePathResolverCell](docs/cells/action-cells.md#basepathresolvercell) ищет
`config/integrity.json` вверх по иерархии каталогов и сохраняет найденный путь,
а [InitConfigCell](docs/cells/action-cells.md#initconfigcell) устанавливает переменную
`INTEGRITY_ROOT`, если она не задана. Достаточно запустить сервис:

```bash
cargo run -p backend
```

Явная установка `INTEGRITY_ROOT` требуется только при запуске вне репозитория или
при нестандартном расположении конфигурации.

Иммунная система Нейры проверяет целостность, помещает подозрительные компоненты в карантин и при необходимости включает безопасный режим. Подробнее см. [docs/immune_system.md](docs/immune_system.md).

## Оглавление

- [Назначение](#назначение)
- [Технические требования](#технические-требования)
  - [Минимальное окружение](#минимальное-окружение)
  - [Распределение вычислений](#распределение-вычислений)
  - [Доступ к аппаратным ускорителям](#доступ-к-аппаратным-ускорителям)
  - [Архитектура памяти](#архитектура-памяти)
  - [Резервирование](#резервирование)
- [Минимальная конфигурация (MVP)](#минимальная-конфигурация-mvp)
- [Ключевые компоненты](#ключевые-компоненты)
- [Поддерживающие системы](#поддерживающие-системы)
- [Планировщик и лимиты итераций](#планировщик-и-лимиты-итераций)
- [Эволюция и оптимизация](#эволюция-и-оптимизация)
- [Автономное создание подтипов и метаданные](#автономное-создание-подтипов-и-метаданные)
- [Эмоции, желания и этика](#эмоции-желания-и-этика)
- [Интеграция с редакторами/IDE](#интеграция-с-редакторамиide)
- [План разработки](#план-разработки)
- [Использование](#использование)
- [Дополнительная документация](#дополнительная-документация)
- [Development](#development)

## Назначение

**Нейра** — экспериментальный модуль искусственного интеллекта,
который расширяет возможности редакторов и IDE за счёт самообучения,
планирования и интерактивного взаимодействия с пользователем.
Модуль строится как набор клеток (cells), которые можно объединять,
оптимизировать и визуализировать в совместимых интерфейсах.

## Технические требования

Эти требования описывают минимальные системные ресурсы, необходимые для запуска Нейры.

### Минимальное окружение

Ниже приведён минимальный набор системных ресурсов и зависимостей, достаточный для запуска Нейры:

- **ОС**: Linux x86_64 (проверено на Ubuntu 22.04 LTS).
- **CPU**: 4 ядра x86_64 или ARM, 2 ГГц+.
- **RAM**: минимум 8 ГБ (рекомендуется 16 ГБ).
- **Диск**: 10 ГБ свободного пространства.
- **Сеть**: гигабитная LAN или выше, RTT <1 мс.
- **Cell runtime**: Node.js 20 LTS или выше.
- **Rust**: версия 1.75 или выше.

GPU необязательна; для обучения и больших моделей желателен CUDA‑совместимый ускоритель с 6 ГБ VRAM.

Для расширения и ускорения вычислений можно использовать оборудование уровня [NVIDIA Data Center GPU](https://www.nvidia.com/en-us/data-center/).

#### Стандартная конфигурация

Для комфортной разработки рекомендуется использовать стандартную конфигурацию:

- 8-ядерный CPU ≥2.5 ГГц
- 32 ГБ RAM
- SSD 512 ГБ
- Опциональная CUDA-совместимая GPU ≥8 ГБ VRAM

Эта конфигурация обеспечивает баланс удобства разработки и стоимости и применяется по умолчанию, если проект не предъявляет особых требований.

Примечание: операционные лимиты планировщика устанавливаются отдельно и поддерживаются ниже указанных значений, чтобы оставлять резерв для хоста и других процессов.

Бюджет `TaskScheduler` всегда задаётся меньше физических ресурсов и служит внутренним ограничением для распределения задач. Например, на машине с 4 CPU и 8 ГБ RAM планировщик по умолчанию резервирует 2 CPU и 4 ГБ, оставляя остальное хосту.

### Распределение вычислений

- **CPU**: планировщик, SynapseHub, обработка памяти.
- **GPU**: обучение, тяжёлые матричные операции.

### Доступ к аппаратным ускорителям

Neira может использовать дополнительные ускорители (GPU, TPU, FPGA) для выполнения ресурсоёмких задач. Общая схема подключения:

1. Клетка указывает требуемый тип ускорителя в поле `required_accelerator` метаданных.
2. `TaskScheduler` распределяет задачи по доступным устройствам, учитывая это поле.
3. При запуске клетка проверяет наличие нужного ускорителя и завершает работу с ошибкой, если устройство недоступно.

Для взаимодействия с различными устройствами применяются специализированные crates:

- [`wgpu`](https://crates.io/crates/wgpu) — универсальный доступ к GPU на разных платформах;
- [`cuda`](https://crates.io/crates/cuda) — API для NVIDIA GPU;
- [`opencl`](https://crates.io/crates/opencl3) — интерфейс для OpenCL‑совместимых GPU/FPGA.

Пример `ActionCell`, который требует GPU и регистрируется в `CellRegistry` вместе с клетками анализа и памяти:

```rust
use anyhow::{bail, Result};
use wgpu::Instance;
use neira::{cells::{ActionCell, AnalysisCell, MemoryCell}, CellRegistry};

struct GpuRender;

impl ActionCell for GpuRender {
    fn start(&self) -> Result<()> {
        let instance = Instance::default();
        if instance.enumerate_adapters(wgpu::Backends::all()).next().is_none() {
            bail!("GPU accelerator not available");
        }
        Ok(())
    }
}

struct Plan;
impl AnalysisCell for Plan {}

struct Store;
impl MemoryCell for Store {}

fn main() -> Result<()> {
    let mut registry = CellRegistry::default();
    registry.register_action("render", Box::new(GpuRender));
    registry.register_analysis("plan", Box::new(Plan));
    registry.register_memory("store", Box::new(Store));
    Ok(())
}
```

### Архитектура памяти

Память Нейры организована по уровням — от самых быстрых к более ёмким и медленным хранилищам:

1. **CPU‑кэш** — микросекундный доступ к данным, задействованным в текущих вычислениях.
2. **ОЗУ** — основная рабочая область, где хранится оперативный контекст и структуры данных клеток.
3. **VRAM GPU** — тензоры и модели, используемые для ускоренных операций на графических процессорах.
4. **NVRAM/PMEM** — энергонезависимая память с задержкой порядка сотен наносекунд и объёмами десятки–сотни гигабайт.
5. **SSD** — постоянные клетки памяти и индексы, требующие быстрого чтения и записи.
6. **HDD** — архивы и редко запрашиваемые данные, переносимые в медленное хранилище.
7. **Базы данных** — активные располагаются на SSD, архивные — на HDD.

Последние уровни задействуются по мере роста объёма знаний и потребности в долговременном хранении.

### Резервирование

Для предотвращения потери данных используется зеркалирование SSD и активных баз данных (RAID 1/5). Критичные клетки памяти дублируются на резервных машинах, что позволяет быстро восстановить работу при отказе оборудования.

**Критерии выбора стратегии:**

- критичность клетки;
- стоимость простоя;
- объём данных.

## Личность Нейры

Стартовый образ и правила развития описаны в [отдельном документе](docs/meta/personality.md).
Кратко: на старте система проецирует образ 14‑летней девочки, увлекающейся анализом и играми.
По мере роста функциональности персонаж взрослеет до примерно 30 лет, но базовые черты сохраняются.
При необходимости доступен режим без личности для сухих академических ответов.

## Минимальная конфигурация (MVP)

Базовая версия Neira реализуется на Rust и включает:

1. **Коммуникационный клетка (Chat Cell)** – Telegram или Discord‑бот для диалога с разработчиком.
2. **Клетка генерации кода (Code Cell)** – создаёт и модифицирует исходный код.
3. **Клетка саморазвития (Self-Improve Cell)** – анализирует систему и предлагает патчи.
4. **Клетки действий, анализа и памяти** – определяют и выполняют операции, хранят знания.
5. **Рабочая память** – удерживает текущий контекст и промежуточные результаты.
6. **Базовый планировщик** – распределяет задачи и ограничивает итерации.
7. **Интерфейс разработчика** – просмотр логов, подтверждение изменений, запуск обучения.
8. **Контролируемая среда обучения** – загрузка книг и локальных источников.
9. **Ядро личности** – правила и ценности, влияющие на ответы.

Этот минимальный набор служит отправной точкой и будет расширяться по мере развития Нейры.

На ранних этапах при необходимости подключается внешний тьютор (например, LLM‑сервис),
помогающий с подсказками и обучением. Архитектура рассчитана на постепенное
саморазвитие, поэтому зависимость от тьютора со временем исчезает.

## Ключевые компоненты

![Диаграмма систем Neira](architecture.svg)

### 1. Клетки действий (Action Cells)

Отвечают за конкретные операции: вывод текста,
запросы к API, генерацию кода, мониторинг состояния и т.д.

```rust
struct ActionCell {
    id: String,
    action_type: ActionType,
    connections: HashMap<String, f32>,
    execution_cache: LruCache<String, ExecutionResult>,
    metrics: ActionMetrics,
}
```

### 2. Клетки анализа (Analysis Cells)

Обрабатывают запросы, строят логические цепочки,
оценивают достоверность данных и выбирают нужные действия. В базовом интерфейсе обязательны
поля `id`, `analysis_type`, `status`, `links`, `confidence_threshold` и `metadata.schema`. Цепочка рассуждений (`reasoning_chain`) формируется во время анализа и хранится в `AnalysisResult`.

```rust
struct AnalysisCell {
    id: String,
    analysis_type: AnalysisType,
    status: CellStatus,
    links: Vec<String>,
    confidence_threshold: f32,
    metadata: AnalysisMetadata,
}

struct AnalysisMetadata {
    schema: String,
    // дополнительные метаданные
}
```

`status` фиксирует состояние клетки (`draft`, `active`, `deprecated`, `error`) и
используется планировщиком и системами ревизий. Обязательное поле `links`
перечисляет связанные клетки и помогает планировщику ориентироваться в графе.
`confidence_threshold` задаёт минимальную допустимую `credibility` для принятия результата,
а `metadata.schema` содержит версию схемы описания клетки. Последовательность рассуждений возвращается отдельно в `AnalysisResult`, что упрощает аудит и отладку.

При выполнении `analyze()` клетка формирует `AnalysisResult` с метриками `quality_metrics`,
цепочкой `reasoning_chain`, вычисленным `uncertainty_score` и ссылками на использованные источники.

### 3. Клетки памяти (Memory Cells)

Хранят знания и опыт, поддерживают приоритизацию источников
и ведут журнал ошибок.

```rust
struct MemoryCell {
    id: String,
    data_type: MemoryType,
    priority_level: Priority,
    source_reliability: SourceReliability,
    access_frequency: u32,
    last_accessed: DateTime<Utc>,
}
```

### 4. Личностные модули

Включают элементы, отвечающие за образ персонажа и игровые сценарии:

- **Диалоговая логика** — определяет намерение пользователя и выбирает стиль ответа.
- **Модуль личности** — хранит устойчивый образ Нейры и позволяет отключать его при необходимости.
- **Модуль интересов и игр** — обеспечивает обучение через участие в играх и формирование новых аналитических клеток.
- **Модуль скепсиса и проверки** — добавляет уточнения и проверку фактов.

### Взаимодействие с другими клеткими

Клетки связываются через направленные рёбра данных и событий, формируя граф выполнения.

```mermaid
flowchart LR
    Action[Клетка действия] -->|событие| Analysis[Клетка анализа]
    Analysis -->|контекст| Memory[Клетка памяти]
    Memory -->|обновление| Analysis
    Analysis -->|команда| Action
```

## Поддерживающие системы

- **Рабочая память и внимание** — отслеживает текущий контекст диалога,
  фокусируется на релевантных данных, очищает устаревшие записи.
- **Планирование и цели** — разбивает задачи на подцели,
  оценивает ресурсы и отслеживает прогресс.
- **Учёт неопределённости** — для каждого вывода вычисляется вероятность
  и объясняется источник сомнений.
- **Метапознание** — модуль самооценки анализирует собственные рассуждения
  и выбирает альтернативные стратегии.
- **Сбор метрик и диагностика** — фиксирует показатели качества,
  пытается исправлять ошибки автоматически и уведомляет разработчика при
  превышении порога. Подробнее см. [документ](docs/metrics_cells.md).

Подробнее см. [поддерживающие системы](docs/system/support-systems.md).

## Планировщик и лимиты итераций

Этот раздел описывает операционные лимиты планировщика. Они определяют, сколько времени и итераций выделяется клетким и не являются пределами физических ресурсов системы.

`TaskScheduler` распределяет задачи по очередям `fast`, `standard` и `long`, учитывая параметры `priority`, `max_iterations` и `time_slice_ms`. Подробности см. в разделе [TaskScheduler](docs/system/support-systems.md#taskscheduler).

Планировщик может учитывать отдельный бюджет `pmem_limit_mb` для энергонезависимой памяти, чтобы клетки не превышали доступный объём NVRAM.

Планировщик определяет порядок активации клеток и контролирует количество циклов обработки. Он поддерживает приоритеты, задержки и политики останова.

### Базовые параметры

Каждый клетка может задавать:

- **priority** — значение от 0 до 10, чем выше, тем раньше выполняется клетка;
- **max_iterations** — предел повторов, предотвращает бесконечные циклы;
- **time_slice_ms** — квант времени, после которого управление передаётся другому клетке.

```toml
[scheduler]
default_priority = 1
max_iterations = 32
time_slice_ms = 10
```

Параметры можно переопределять в пользовательском профиле или через UI.

Операционные лимиты планировщика обычно ниже доступных аппаратных ресурсов, чтобы оставлять резерв для системы и параллельных процессов.

### Тонкая настройка

Планировщик отслеживает фактическое время выполнения клеток и автоматически корректирует лимиты. Для долгих задач лимиты могут увеличиваться, для фоновых — снижаться. Пользователь может задать глобальный предел по времени или количеству итераций, после которого выполнение приостанавливается с уведомлением.

## Эволюция и оптимизация

Нейра отслеживает часто используемые цепочки клеток и создаёт «мосты» (BridgeCell)
для ускорения повторяющихся операций. Метрики успеха, производительности
и частоты использования формируют вес оптимизации. Возможна кодогенерация
новых клеток с последующим ручным подтверждением разработчика.

- Новые клетки запускаются параллельно со старыми.
- Пользователь тестирует устойчивость и функциональность.
- После одобрения новая версия становится основной, а прежняя архивируется или удаляется.

Связанные этапы описаны в [жизненном цикле клеток](docs/cells/cell-lifecycle.md).

## Автономное создание подтипов и метаданные

При обнаружении повторяющихся шаблонов взаимодействий система создаёт новые специализированные подтипы клеток. Процесс включает анализ метрик, генерацию исходного кода и описание метаданных.

```json
{
  "subtype": "analysis/semantic-filter",
  "version": 1,
  "author": "neira",
  "parameters": { "threshold": 0.7 },
  "connections": ["memory/long-term", "action/report"]
}
```

Метаданные хранятся в формате JSON и используются редактором для визуализации и проверки совместимости. Пользователь может разрешить автоматическое добавление подтипов или требовать ручного подтверждения.

## Эмоции, желания и этика

Имитация эмоций упрощает общение с пользователем. Настоящие эмоции
служат механизмами саморегуляции (лень, любопытство и т.д.). Система
гипер‑желаний позволяет задавать стратегические цели, на основе которых
формируются более конкретные задачи.

## Интеграция с редакторами/IDE

- Написан на Rust и может запускаться как отдельный сервис или библиотека.
- Визуализация клеток и их связей возможна в редакторах, поддерживающих
  @VISUAL_META‑метаданные.
- Обмен данными осуществляется через WebSocket или другие API,
  что позволяет подключать различные фронтенд‑платформы.

## План разработки

1. **Базовые клетки и рабочая память** — создание Action/Analysis/Memory клеток
   и механизма контекста.
2. **Планирование и неопределённость** — внедрение PlanningSystem
   и UncertaintyQuantification.
3. **Метапознание и оптимизация** — запуск систем самооценки и мостов.
4. **Эмоции и желания** — добавление имитации эмоций, саморегуляции
   и гипер‑желаний.
5. **Визуализация и интеграция** — полноценное отображение клеток,
   трассировка и отладка внутри выбранного редактора или IDE.

## Использование

Модуль может запускаться как часть приложения spinal_cord или как отдельный процесс.
Функциональность можно подключать поэтапно, позволяя разработчикам
добавлять клетки и адаптировать поведение системы под потребности
конкретного проекта.

<!-- neira:meta
id: NEI-20260511-readme-spinalcord-app
intent: docs
summary: Уточнено, что модуль запускается как часть приложения spinal_cord.
-->

<!-- neira:meta
id: NEI-20250214-organ-builder-cli-docs
intent: docs
summary: Добавлены примеры использования утилиты organ_builder.
-->

### Organ Builder CLI

```bash
# Сборка органа из JSON-шаблона
cargo run -p backend --bin organ_builder -- build path/to/template.json

# Проверка статуса
cargo run -p backend --bin organ_builder -- status organ-1

# Отмена сборки
cargo run -p backend --bin organ_builder -- cancel organ-1
```

По умолчанию базовый URL берётся из переменной окружения `NEIRA_API_BASE`. Его можно
указать явно последним аргументом команд.

Подробные инструкции по установке зависимостей,
запуску демонстрационной конфигурации и настройке
переменных окружения приведены в [docs/legacy/deployment.md](docs/legacy/deployment.md).

## Дополнительная документация

- [Клетки действий](docs/cells/action-cells.md)
- [Клетки памяти](docs/cells/memory-cells.md)
- [Клетки анализа](docs/cells/analysis-cells.md)
- [Механизм саморазвивающейся системы](docs/system/self-updating-system.md)

## Development

- [Интеграция IDE](docs/guides/ide-integration.md)

<!-- neira:meta
id: NEI-20250214-120100-pre-commit-doc
intent: docs
summary: |
  Добавлены инструкции по установке локальных pre-commit хуков.
-->
### Pre-commit

Установите локальные хуки для форматирования и линтинга:

```bash
pre-commit install
```

## Схемы

JSON‑схемы расположены в каталоге [schemas](schemas). При несовместимых изменениях повышайте версию: `1.0.0` → `1.1.0`.

<!-- neira:meta
id: NEI-20261015-digestive-cache-doc
intent: docs
summary: Описан кэш JSON Schema DigestivePipeline и способ сброса.
-->
### Кэш DigestivePipeline

DigestivePipeline хранит загруженные JSON Schema в глобальном кэше в памяти процесса. Схема считывается с диска только один раз. Чтобы сбросить кэш, перезапустите приложение или вызовите `DigestivePipeline::reset_cache()`.

## Тесты

Запуск тестов:

```bash
npm test
cargo test
```

## CI/CD

Основные команды конвейера:

```bash
npm run build
npm test
cargo build --release
cargo test
npm pack
cargo package
scp target/release/neira user@server:/opt/neira
```

Подробнее см. [docs/legacy/deployment.md](docs/legacy/deployment.md).

## Подключение пользовательского плагина

Neira поддерживает пользовательские системные плагины. Для интеграции
нужно реализовать трейt [`SystemProbe`](spinal_cord/src/nervous_system/mod.rs) и
запустить его в фоне:

<!-- neira:meta
id: NEI-20240607-systemprobe-doc-stop
intent: docs
summary: Пример SystemProbe обновлён методом stop.
-->

```rust
use neira::nervous_system::SystemProbe;

struct CustomProbe;

#[async_trait::async_trait]
impl SystemProbe for CustomProbe {
    async fn start(&mut self) {
        // фоновый цикл мониторинга
    }

    fn collect(&mut self) {
        // сбор и публикация метрик
    }

    fn stop(&mut self) {
        // завершение фонового цикла
    }
}

let mut probe = CustomProbe;
tokio::spawn(async move { probe.start().await; });
```
[Spinal cord API Quick Reference](docs/api/spinal_cord.md)
