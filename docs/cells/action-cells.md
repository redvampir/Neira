# Клетки действий

<!-- neira:meta
id: NEI-20250317-120200-action-cells-schema-link
intent: docs
summary: Обновлена ссылка на JSON-схему action-cell-template.
-->

## Навигация

- [Обзор Нейры](README.md)
- [Клетки действий](action-cells.md)
- [Клетки анализа](analysis-cells.md)
- [Клетки памяти](memory-cells.md)
- [Архитектура анализа](analysis-architecture.md)
- [Поддерживающие системы](support-systems.md)
- [Личность Нейры](personality.md)
- [Шаблон клетки](cell-template.md)
- [Политика источников](source-policy.md)
- [Механизм саморазвивающейся системы](self-updating-system.md)

## Оглавление

- [MVP ActionCells](#mvp-actioncells)
- [Виды клеток действий](#виды-клеток-действий)
- [Архитектурные принципы](#архитектурные-принципы)
- [Пример сценария](#пример-сценария)
- [Дальнейшее развитие](#дальнейшее-развитие)

Клетки действий отвечают за все активные операции нейросистемы — от мониторинга оборудования до внешних интерфейсов. Они исполняют решения клеток анализа, используя данные клеток памяти.

## MVP ActionCells

Начальный набор клеток действий (MVP) содержит три типа. В каждом примере поле `action_type` указывает тип действия, а `id` — уникальный идентификатор клетки:

1. **Chat**
   Обеспечивает диалог и генерацию текстовых ответов.

   ```json
   {
     "id": "example.chat",
     "action_type": "chat",
     "prompt": "Расскажи о проекте Neira"
   }
   ```

2. **Code**
   Генерирует или изменяет фрагменты кода.

   ```json
   {
     "id": "example.code",
     "action_type": "code",
     "language": "python",
     "task": "Напиши функцию fibonacci(n)"
   }
   ```

3. **Self-Improve**
   Переоценивает текущие модули, предлагает обновления и интегрирует новые клетки.
   ```json
   {
     "id": "example.self_improve",
     "action_type": "self_improve",
     "goal": "оптимизировать использование памяти"
   }
   ```

Дополнительные ActionCells (работа с файлами, внешние API и т.п.) будут добавлены после MVP.

### Шаблоны

Шаблон клетки действия описывается JSON‑файлом, соответствующим схеме
[`schemas/v1/action-cell-template.schema.json`](../../schemas/v1/action-cell-template.schema.json).
Пример реализации —
[`examples/factory/voice-v1/action.speak_adapter.v1.json`](../../examples/factory/voice-v1/action.speak_adapter.v1.json).

### Пример HTTP/JSON/TOML вызова

Запрос к API клеток действий передаётся в формате JSON.

```http
POST /api/neira/action HTTP/1.1
Host: localhost:4000
Content-Type: application/json

{
  "id": "example.chat",
  "action_type": "chat",
  "prompt": "Расскажи о проекте Neira"
}
```

Ответ:

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": "example.chat",
  "status": "ok",
  "result": "Neira — саморазвивающийся модуль..."
}
```

Эквивалентная конфигурация в формате TOML:

```toml
id = "example.chat"
action_type = "chat"
prompt = "Расскажи о проекте Neira"
```

### Реализация на правилах (ранние версии)

Для первичных прототипов каждый ActionCell можно реализовать набором простых правил:

- **Chat** — использует заранее подготовленный текст запроса. Поле `prompt` заполняется вручную и задаёт фиксированную форму обращения к модели. В дальнейшем `prompt` может строиться автоматически на основе контекста и связанных клеток памяти.
- **Code** — содержит список допустимых языков и задач. Поля `language` и `task` вводятся разработчиком и определяют генерируемый фрагмент. Со временем выбор языка и формулировка задачи могут определяться результатами анализа и историей пользователя.
- **Self-Improve** — опирается на статический набор критериев. Поле `goal` задаётся вручную (например, «оптимизировать использование памяти») и позже может выводиться из метрик и A/B‑тестов.

Во всех случаях `id` и `action_type` задаются вручную. Прочие поля на раннем этапе также заполняются человеком, но в будущем их возможно формировать автоматически или заменять обучаемыми моделями.

## Виды клеток действий

### Внутренние действия

1. **Система отслеживания состояния железа (Лени)**
   Постоянно считывает показатели CPU, GPU, RAM, дисков и сети. На основе телеметрии прогнозирует
   перегрузки, выдаёт предупреждения и при необходимости перераспределяет ресурсы между клеткими.

2. **Поиск в интернете**
   Обращается к внешним поисковым API, агрегирует и ранжирует результаты. Кэширует ответы,
   отслеживает ограничения лицензий и фильтрует нерелевантные данные.

3. **Преобразование источников информации**
   Парсят файлы, веб‑страницы и потоковые данные, приводя их к внутренним форматам. Выполняют
   очистку, нормализацию, извлечение структурированных фактов и векторизацию.

4. **Создание новых клеток и мостов**
   Динамически расширяют структуру нейросистемы: порождают новые клетки, связывают их мостами и
   интегрируют плагины. Обеспечивают миграцию данных и схем при обновлениях.

5. **Самоанализ и реконфигурация**
   Сравнивают метрики эффективности, проводят A/B‑тесты и адаптируют архитектуру. Могут
   переобучать модели, отключать неэффективные компоненты и предлагать оптимизации.

6. **Расщепление сознания**
   Запускают параллельные субпроцессы для одновременного выполнения нескольких задач. Синхронизируют
   их состояние и при завершении объединяют результаты.

7. **Прочие механизмы**
   Включают службы логирования, диагностики, планировщики задач и средства оптимизации.

### Внешние взаимодействия

Клетки действий предоставляют пользователю и внешнему миру набор интерфейсов.

1. **Генерация ответа и написание кода**
   Формирует тексты, диалоги и программные фрагменты. Поддерживает форматирование и вставку в
   различные среды.

2. **Перевод и адаптация источников**
   Автоматически переводит внешние материалы на нужный язык, сохраняет контекст и структуру.

3. **Преобразование поступающих источников**
   Конвертирует файлы и потоки в стандартизованные форматы, обеспечивает совместимость с внутренней
   памятью.

4. **Создание интерфейсов (будущее)**
   Разработка внешних UI/UX‑средств.

5. **Система зрения (будущее)**
   Обработка изображений и видео.

6. **Система голоса (будущее)**
   Синтез и распознавание речи.

7. **Система рисования (будущее)**
   Генерация графики и визуальных схем.

8. **Другие внешние системы (будущее)**
   Дополнительные способы взаимодействия.

## Архитектурные принципы

1. **Модульность** — каждый клетка выполняет одну функцию, легко заменяется или расширяется без
   затрагивания остальных компонентов.
2. **Интероперабельность** — взаимодействие через стандартизированные API и общие форматы данных.
3. **Безопасность** — изоляция внутренних клеток, контроль доступа и защита внешних обменов.
4. **Параллельность** — поддержка одновременного выполнения множества задач и синхронизация результатов.
5. **Логирование и телеметрия** — фиксация всех действий для диагностики, обучения и воспроизводимости.

## Пример сценария

1. Пользователь задаёт вопрос.
2. Клетки анализа определяют необходимость поиска в интернете и генерации ответа.
3. Активируются клетки действий: поиск, преобразование данных, генерация ответа.
4. Результат отправляется пользователю и при необходимости сохраняется в памяти.

## Дальнейшее развитие

- Добавление новых модулей (планирование, обучение, обработка сенсоров).
- Повышение автономности за счёт самоанализа и реконфигурации.
- Интеграция с внешними сервисами и базами знаний.
- Эволюция клеток: новые варианты запускаются параллельно и проходят пользовательское тестирование перед заменой старых (см. [раздел «Эволюция и оптимизация»](README.md#эволюция-и-оптимизация)).

## Системные ActionCells

### BasePathResolverCell

Определяет базовый путь проекта. Клетка поднимается от текущего исполняемого файла вверх по иерархии каталогов,
пока не найдёт `config/integrity.json`, и сохраняет найденный путь в память.

### InitConfigCell

Инициализирует конфигурацию при старте. Если переменная окружения `INTEGRITY_ROOT` не задана,
клетка читает базовый путь из памяти (см. `BasePathResolverCell`) и устанавливает её автоматически.

## Схемы

JSON‑схемы расположены в каталоге [schemas](schemas). При несовместимых изменениях повышайте версию: `1.0.0` → `1.1.0`.
